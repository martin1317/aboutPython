#! /usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = "Q1mi"
# Date: 2017/1/7

"""
一道经典的lambda表达式问题：
bar = [lambda x: x + i for i in range(10)]
ret = bar[7](1000)
print(ret)

问：打印的结果是什么？

"""

bar = [lambda x: x + i for i in range(10)]
ret = bar[7](1000)
print(ret)

# --------------------------------------------------分割线-------------------------------------------------------------

# 让我们来分析下 bar = [lambda x: x + i for i in range(10)]
# 1. 首先bar是一个列表
# 2. 再具体一点是长度为10的列表，里面的元素都是lambda表达式 x+i
# 3. 比较关键的地方就是bar并不是你想的那样等于[lambda x: x + 1, lambda x: x + 2, ...lambda x: x + 9]
# 4. bar实际上等于[lambda x: x + 9, lambda x: x + 9, ...lambda x: x + 9]

# --------------------------------------------------分割线-------------------------------------------------------------

# 要理解上面的第3条和第4条的话，我们先把bar拆解成下面的代码

bar = []
for i in range(10):
    bar.append(lambda x: x+i)
ret = bar[7](1000)
print(ret)
# 如你所见，上面的代码，你可以试一下，不管bar[7](1000)，还是bar[0](1000)都是返回1009

# --------------------------------------------------分割线-------------------------------------------------------------

# 那为什么会是这样呢？看起来i的值被固定为9了啊？
# 让我们来搞点事情：

bar = []
for i in range(10):
    bar.append(lambda x: x+i)
i = 99
ret = bar[7](1000)
print(ret)

# 显然此时的结果变成了1099，为什么呢？因为我们手动修改了i的值
# 不知道你注意了没有，我们是在bar这个列表生成之后才修改的i的值，但是bar里面的函数表达式还是引用的修改之后的值
# 是的，bar里面的函数表达式就是引用的i的值，在同一个作用域下这个i的值一直在变化，并不会记为每次i的值而是简单的记为i
# 所以在函数被调用之前，在同一作用域内对i的修改都会影响到函数表达式里面的i的值
# 也就是说，函数表达式里只是保存了一个变量i，并不是具体的数。这个变量是可以随时被改变，并影响函数表达式中的i

# --------------------------------------------------分割线-------------------------------------------------------------

# 函数只有在调用的时候才会执行，在这个例子里面bar里面是10个一样的函数：return x + i，
# 你在调用之前修改一下i的值，那么返回的就是x+'你修改之后的值'。
# 也就是下面这段代码：


def func(x):
    return x + i

bar = [func, func, func, func, func, func, func, func, func, func]
i = 9
ret = bar[7](1000)  # ret = func(1000)
print(ret)
